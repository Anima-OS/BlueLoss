import { Socket } from 'net'
import util from 'util'

import getDefaultGateway from 'default-gateway'
import _ from 'lodash'
import ms from 'ms'
import arp from 'node-arp'
import getInternalIP from 'internal-ip'
import Promise from 'nuo'

import { getSettings } from '../db/settings.lsc'
import { handleScanResults } from './handleScanResults.lsc'
import { logger } from '../common/logging/logging.lsc'
import { DeviceType, DefaultGatewayType } from '../types/types.lsc'

pGetMAC = util.promisify(arp.getMAC)
scanInterval = ms('30 seconds')

scanNetwork():Promise<any> ->
  logger.debug(`new scan started`)
  {
    hostsScanRange: { start: hostsRangeStart, end: hostsRangeEnd },
    hostScanTimeout
  } = getSettings()

  Promise.resolve(getDefaultGateway.v4())
    .then((defaultGateway: DefaultGatewayType) ->
      logger.debug(`gateway ip: ${ defaultGateway }`)
      generateHostIPs(defaultGateway, hostsRangeStart, hostsRangeEnd)
    )
    .then(hostIPs => {
      hostIPs.forEach(hostIP => {
        scanHost(hostIP, hostScanTimeout)
        .then(getMacAdressForHostIP)
        .then(getVendorInfoForMacAddress)
        .then(handleScanResults)
        .catch(logger.error)
      })
    })
    .finally(():void -> setTimeout(scanNetwork, scanInterval))


// http://bit.ly/2pzLeD3
scanHost(hostIP: string, hostScanTimeout: number): Promise<any> ->
  new Promise((resolve, reject):void ->
    socket = new Socket()

    socket.setTimeout(hostScanTimeout)
    socket.connect({ host: hostIP, port: 1 })
    socket.unref()

    socket.on('error', (error):void ->
      if error.code === 'ECONNREFUSED': resolve(hostIP)
      else: reject(error)
    )
    socket.on('timeout', ():void -> socket.destroy())
    socket.on('connect', ():void ->
      resolve(hostIP)
      socket.destroy()
    )
  )

getMacAdressForHostIP(activeHostIP: string):Promise<any> ->
  pGetMAC(activeHostIP)
    .catch((err): void ->
      logger.error(`couldn't get MAC adress for: ${ activeHostIP }`, err)
    )
    .then(macAddress -> ({ ipAddress: activeHostIP, macAddress }))


getVendorInfoForMacAddress({ ipAddress, macAddress }):Promise<DeviceType> ->
  if !getSettings().getMacVendorInfo: return { ipAddress, macAddress }
  ouiSansDelimeters = macAddress.replace(/[.:-]/g, "").substring(0, 6)
  // use a native for loop here cause the OUI file is over 20,000 lines long
  // indexOf seems to be the fastest string checker: http://bit.ly/2pABrgG
  getOUIfileData()
  for elem line in ouiFileData:
    if line.indexOf(ouiSansDelimeters) === 0:
      vendorName = line.split(ouiSansDelimeters)[1].trim()
      return Promise.resolve({ ipAddress, macAddress, vendorName })
  Promise.resolve({ ipAddress, macAddress, vendorName: null })


generateHostIPs(gateway, hostsRangeStart, hostsRangeEnd):Array<string> ->
  networkOctects = gateway.slice(0, gateway.lastIndexOf('.'))
  internalIp = getInternalIP.v4.sync()

  _.range(hostsRangeStart, hostsRangeEnd)
      .map((lastOctet:string) -> `${ networkOctects }.${ lastOctet }`)
      .filter((hostIP:string) -> hostIP !== gateway and hostIP !== internalIp)



export {
  scanNetwork,
}
