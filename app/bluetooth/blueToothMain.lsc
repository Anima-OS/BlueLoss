import path from 'path'
import url from 'url'
import { BrowserWindow } from 'electron'

import tp from 'timeproxy'

import { handleScanResults } from './handleScanResults.lsc'
import { logger } from '../common/logging/logging.lsc'
import { getSettings } from '../settings/settings.lsc'
import { lockSystemIfDeviceLost } from './lockCheck.lsc'

bluetoothHiddenWindowHTMLpath = url.format({
  protocol: 'file',
  slashes: true,
  pathname: path.resolve(__dirname, '..', 'bluetooth', 'renderer', 'bluetoothHiddenWindow.html')
})

bluetoothHiddenWindowProperties = {
  show: ISDEV,
  webPreferences: {
    experimentalFeatures: true, // for web-bluetooth
    devTools: ISDEV
  }
}

let scannerWindow = null  // so it doesn't get garbage collected
scanInterval = tp.TEN_SECONDS

init():void ->
  createBluetoothScannerWindow().then(scanforDevices)

createBluetoothScannerWindow():Promise ->
  new Promise((resolve):void ->
    now scannerWindow = new BrowserWindow(bluetoothHiddenWindowProperties)
    scannerWindow.loadURL(bluetoothHiddenWindowHTMLpath)
    if ISDEV: scannerWindow.webContents.openDevTools({ mode: 'undocked'})

    scannerWindow.webContents.once('dom-ready', resolve)
    scannerWindow.webContents.on('select-bluetooth-device', handleScanResults)
    scannerWindow.webContents.once('crashed', (event):void ->
      logger.error('scannerWindow.webContents crashed', event)
    )
    scannerWindow.once('unresponsive', (event):void ->
      logger.error('scannerWindow unresponsive', event)
    )
  )

scanforDevices():void ->
  if !getSettings().blueLossEnabled: return scanIn10Seconds()

  scannerWindow
    .webContents
    .executeJavaScript(`navigator.bluetooth.requestDevice({acceptAllDevices: true}).catch(e =>{})`, true)
    .catch(logger.error)
    .then(lockSystemIfDeviceLost)
    .then(scanIn10Seconds)


scanIn10Seconds():void ->
  setTimeout(scanforDevices, scanInterval)


export {
  init,
}

